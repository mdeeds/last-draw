<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Cosine Blur Tool</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: 'Inter', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 100vh;
      margin: 0;
      overflow: hidden;
    }

    canvas {
      border: 2px solid #4a5568;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      touch-action: none;
      /* Prevents default touch actions like scrolling */
    }

    .info-box {
      background-color: #2d3748;
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
      text-align: center;
      font-size: 0.875rem;
      color: #a0aec0;
    }
  </style>
</head>

<body>
  <div class="flex flex-col items-center p-4">
    <h1 class="text-3xl font-bold mb-4 text-white">WebGL Cosine Blur Tool</h1>
    <canvas id="blurCanvas"></canvas>
    <div class="flex items-center mt-4">
      <input type="checkbox" id="commitCheckbox" class="mr-2 rounded">
      <label for="commitCheckbox" class="text-sm">Commit on Mouse Up</label>
    </div>
    <div class="info-box max-w-sm">
      <p>Click and drag to apply a cosine blur and lightening effect.</p>
      <p>If "Commit on Mouse Up" is checked, the blur will be saved to the canvas.</p>
    </div>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('blurCanvas');
      const gl = canvas.getContext('webgl');

      if (!gl) {
        alert('Your browser does not support WebGL. Please try a different browser.');
        return;
      }

      // Set canvas size
      function setCanvasSize() {
        const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7);
        canvas.width = size;
        canvas.height = size;
      }
      setCanvasSize();
      window.addEventListener('resize', setCanvasSize);

      // Shader source code
      const vertexShaderSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;

      const fragmentShaderSource = `
                precision mediump float;
                uniform sampler2D u_main_texture;
                uniform vec2 u_resolution;
                uniform vec2 u_start;
                uniform vec2 u_end;
                uniform float u_drag_length;
                uniform bool u_is_dragging;

                const float PI = 3.14159265359;
                const int MAX_BLUR_RADIUS = 30; // Max radius to prevent excessive sampling
                
                void main() {
                    vec2 p = gl_FragCoord.xy;
                    
                    vec4 final_color = texture2D(u_main_texture, p / u_resolution);

                    if (!u_is_dragging) {
                        gl_FragColor = final_color;
                        return;
                    }

                    // --- Blur Logic ---

                    // Calculate distance to the "pill" shape
                    vec2 start_to_end = u_end - u_start;
                    vec2 start_to_p = p - u_start;
                    float t = dot(start_to_p, start_to_end) / dot(start_to_end, start_to_end);
                    vec2 closest_point_on_line = u_start + clamp(t, 0.0, 1.0) * start_to_end;
                    float dist_from_line = distance(p, closest_point_on_line);

                    // Interpolate the blur radius based on distance from the pill's edge
                    float inner_radius = u_drag_length * 0.2;
                    float outer_radius = u_drag_length * 1.2;
                    float blur_radius_factor = 1.0 - smoothstep(inner_radius, outer_radius, dist_from_line);
                    float blur_radius = blur_radius_factor * inner_radius;

                    if (blur_radius < 1.0) {
                         gl_FragColor = final_color;
                         return;
                    }

                    vec4 total_color = vec4(0.0);
                    float total_weight = 0.0;
                    
                    for (int x = -MAX_BLUR_RADIUS; x <= MAX_BLUR_RADIUS; ++x) {
                        for (int y = -MAX_BLUR_RADIUS; y <= MAX_BLUR_RADIUS; ++y) {
                            if (abs(float(x)) > blur_radius || abs(float(y)) > blur_radius) {
                                continue;
                            }
                            
                            vec2 offset = vec2(float(x), float(y));
                            
                            // Calculate cosine weights for x and y offsets
                            float weight_x = cos(PI * 0.5 * offset.x / blur_radius);
                            float weight_y = cos(PI * 0.5 * offset.y / blur_radius);
                            float weight = weight_x * weight_y;
                            
                            // Get the color of the neighboring pixel
                            vec4 sampled_color = texture2D(u_main_texture, (p + offset) / u_resolution);
                            
                            total_color += sampled_color * weight;
                            total_weight += weight;
                        }
                    }
                    
                    vec4 blurred_color = total_color / total_weight;
                    
                    // --- Lightening Logic ---
                    // Blend the blurred color with white based on the blur radius factor
                    float lighten_factor = blur_radius_factor * 0.5;
                    gl_FragColor = mix(blurred_color, vec4(1.0, 1.0, 1.0, 1.0), lighten_factor);
                }
            `;

      // Helper functions to create and compile shaders
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // Create program
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
        return null;
      }

      gl.useProgram(program);

      // Look up attribute and uniform locations
      const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
      const mainTextureUniformLocation = gl.getUniformLocation(program, 'u_main_texture');
      const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
      const startUniformLocation = gl.getUniformLocation(program, 'u_start');
      const endUniformLocation = gl.getUniformLocation(program, 'u_end');
      const dragLengthUniformLocation = gl.getUniformLocation(program, 'u_drag_length');
      const isDraggingUniformLocation = gl.getUniformLocation(program, 'u_is_dragging');

      // Create a buffer for a full-screen quad
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      // Set up vertex attribute pointer
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

      // Create textures
      let mainTexture, intermediateTexture;
      let framebuffer;

      function createTexture(width, height) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return texture;
      }

      function initializeTextures() {
        const width = canvas.width;
        const height = canvas.height;

        // Dispose of old resources
        if (mainTexture) gl.deleteTexture(mainTexture);
        if (intermediateTexture) gl.deleteTexture(intermediateTexture);
        if (framebuffer) gl.deleteFramebuffer(framebuffer);

        mainTexture = createTexture(width, height);
        intermediateTexture = createTexture(width, height);

        // Create FBO
        framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, intermediateTexture, 0);

        // Initial clear
        gl.viewport(0, 0, width, height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Draw initial checkerboard to mainTexture
        drawCheckerboard(mainTexture);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }

      function drawCheckerboard(targetTexture) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const ctx = tempCanvas.getContext('2d');
        const tileSize = canvas.width / 16;
        for (let y = 0; y < 16; y++) {
          for (let x = 0; x < 16; x++) {
            ctx.fillStyle = (x + y) % 2 === 0 ? '#000' : '#FFF';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
        gl.bindTexture(gl.TEXTURE_2D, targetTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tempCanvas);
      }

      // Initial uniform values
      let startPoint = { x: 0, y: 0 };
      let dragEndPoint = { x: 0, y: 0 };
      let isDragging = false;
      let currentDragLength = 0;

      const commitCheckbox = document.getElementById('commitCheckbox');

      // Handle mouse events
      canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        startPoint = {
          x: e.clientX - rect.left,
          y: canvas.height - (e.clientY - rect.top)
        };
        dragEndPoint = { ...startPoint };
      });

      canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        dragEndPoint = {
          x: e.clientX - rect.left,
          y: canvas.height - (e.clientY - rect.top)
        };
        updateAndRender();
      });

      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        if (commitCheckbox.checked) {
          // Swap textures to commit the change
          [mainTexture, intermediateTexture] = [intermediateTexture, mainTexture];
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, intermediateTexture, 0);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        updateAndRender();
      });

      // Handle touch events
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        startPoint = {
          x: touch.clientX - rect.left,
          y: canvas.height - (touch.clientY - rect.top)
        };
        dragEndPoint = { ...startPoint };
      });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isDragging) return;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        dragEndPoint = {
          x: touch.clientX - rect.left,
          y: canvas.height - (touch.clientY - rect.top)
        };
        updateAndRender();
      });

      canvas.addEventListener('touchend', () => {
        isDragging = false;
        if (commitCheckbox.checked) {
          [mainTexture, intermediateTexture] = [intermediateTexture, mainTexture];
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, intermediateTexture, 0);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        updateAndRender();
      });

      function updateAndRender() {
        const dx = dragEndPoint.x - startPoint.x;
        const dy = dragEndPoint.y - startPoint.y;
        currentDragLength = Math.sqrt(dx * dx + dy * dy);

        render();
      }

      function render() {
        gl.useProgram(program);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform2f(startUniformLocation, startPoint.x, startPoint.y);
        gl.uniform2f(endUniformLocation, dragEndPoint.x, dragEndPoint.y);
        gl.uniform1f(dragLengthUniformLocation, currentDragLength);
        gl.uniform1f(isDraggingUniformLocation, isDragging ? 1.0 : 0.0);

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(mainTextureUniformLocation, 0);

        // If dragging, render to the intermediate texture. Otherwise, render directly to canvas.
        if (isDragging) {
          gl.bindTexture(gl.TEXTURE_2D, mainTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Unbind FBO
          gl.bindTexture(gl.TEXTURE_2D, intermediateTexture);
        } else {
          gl.bindTexture(gl.TEXTURE_2D, mainTexture);
        }

        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      // Initial setup
      initializeTextures();
      updateAndRender();
    });
  </script>
</body>

</html>